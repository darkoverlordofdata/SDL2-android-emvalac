/* main.c generated by valac 0.34.8, the Vala compiler
 * generated from main.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL2/SDL_video.h>
#include <SDL2/SDL_render.h>
#include <SDL2/SDL_rect.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_events.h>
#include <SDL2/SDL_surface.h>
#include <SDL2/SDL_image.h>

typedef struct _Sprite Sprite;
#define _SDL_DestroyWindow0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyWindow (var), NULL)))
#define _SDL_DestroyRenderer0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyRenderer (var), NULL)))
void sprite_release (Sprite* self);
void sprite_free (Sprite* self);
Sprite* sprite_retain (Sprite* self);
#define _sprite_release0(var) ((var == NULL) ? NULL : (var = (sprite_release (var), NULL)))
typedef struct _Zed Zed;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))

struct _Sprite {
	gint _retainCount;
	SDL_Texture* texture;
	guint16 w;
	guint16 h;
};

struct _Zed {
	gint _retainCount;
};



void sprite_free (Sprite* self);
void draw (SDL_Window* window, SDL_Renderer* renderer, Sprite* sprite);
gint _vala_main (const gchar* args, int args_length1);
Sprite* sprite_new (const gchar* file, SDL_Renderer* renderer);
void zed_free (Zed* self);
static void zed_instance_init (Zed * self);
Zed* zed_retain (Zed* self);
void zed_release (Zed* self);
void zed_free (Zed* self);
Zed* zed_new (const gchar* file, SDL_Renderer* renderer);


void draw (SDL_Window* window, SDL_Renderer* renderer, Sprite* sprite) {
	gint w = 0;
	gint h = 0;
	SDL_Window* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	SDL_Rect destRect = {0};
	Sprite* _tmp3_ = NULL;
	guint16 _tmp4_ = 0U;
	Sprite* _tmp5_ = NULL;
	guint16 _tmp6_ = 0U;
	SDL_Rect _tmp7_ = {0};
	SDL_Renderer* _tmp8_ = NULL;
	Sprite* _tmp9_ = NULL;
	SDL_Texture* _tmp10_ = NULL;
	g_return_if_fail (window != NULL);
	g_return_if_fail (renderer != NULL);
	g_return_if_fail (sprite != NULL);
	_tmp0_ = window;
	SDL_GetWindowSize (_tmp0_, &_tmp1_, &_tmp2_);
	w = _tmp1_;
	h = _tmp2_;
	_tmp3_ = sprite;
	_tmp4_ = _tmp3_->w;
	_tmp5_ = sprite;
	_tmp6_ = _tmp5_->h;
	_tmp7_.x = 0;
	_tmp7_.y = 0;
	_tmp7_.w = (guint) _tmp4_;
	_tmp7_.h = (guint) _tmp6_;
	destRect = _tmp7_;
	_tmp8_ = renderer;
	_tmp9_ = sprite;
	_tmp10_ = _tmp9_->texture;
	SDL_RenderCopy (_tmp8_, _tmp10_, NULL, NULL);
}


gint _vala_main (const gchar* args, int args_length1) {
	gint result = 0;
	SDL_Window* window = NULL;
	SDL_Renderer* renderer = NULL;
	SDL_Window* _tmp0_ = NULL;
	SDL_Renderer* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	Sprite* sprite = NULL;
	SDL_Renderer* _tmp3_ = NULL;
	Sprite* _tmp4_ = NULL;
	Sprite* _tmp5_ = NULL;
	SDL_Texture* _tmp6_ = NULL;
	gboolean done = FALSE;
	SDL_Event event = {0};
	_tmp2_ = SDL_CreateWindowAndRenderer (0, 0, (guint32) 0, &_tmp0_, &_tmp1_);
	_SDL_DestroyWindow0 (window);
	window = _tmp0_;
	_SDL_DestroyRenderer0 (renderer);
	renderer = _tmp1_;
	if (_tmp2_ < 0) {
		result = 2;
		_SDL_DestroyRenderer0 (renderer);
		_SDL_DestroyWindow0 (window);
		return result;
	}
	_tmp3_ = renderer;
	_tmp4_ = sprite_new ("assets/images/background.png", _tmp3_);
	sprite = _tmp4_;
	_tmp5_ = sprite;
	_tmp6_ = _tmp5_->texture;
	if (_tmp6_ == NULL) {
		result = 2;
		_sprite_release0 (sprite);
		_SDL_DestroyRenderer0 (renderer);
		_SDL_DestroyWindow0 (window);
		return result;
	}
	done = FALSE;
	while (TRUE) {
		gboolean _tmp7_ = FALSE;
		SDL_Event _tmp8_ = {0};
		SDL_Renderer* _tmp20_ = NULL;
		SDL_Renderer* _tmp21_ = NULL;
		SDL_Window* _tmp22_ = NULL;
		SDL_Renderer* _tmp23_ = NULL;
		Sprite* _tmp24_ = NULL;
		SDL_Renderer* _tmp25_ = NULL;
		_tmp7_ = done;
		if (!(!_tmp7_)) {
			break;
		}
		SDL_WaitEvent (&_tmp8_);
		 (event);
		event = _tmp8_;
		{
			gboolean _tmp9_ = FALSE;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp12_ = FALSE;
				gboolean _tmp13_ = FALSE;
				SDL_Event _tmp14_ = {0};
				SDL_EventType _tmp15_ = 0;
				if (!_tmp9_) {
					SDL_Event _tmp10_ = {0};
					gint _tmp11_ = 0;
					_tmp11_ = SDL_PollEvent (&_tmp10_);
					 (event);
					event = _tmp10_;
					if (!(_tmp11_ > 0)) {
						break;
					}
				}
				_tmp9_ = FALSE;
				_tmp14_ = event;
				_tmp15_ = _tmp14_.type;
				if (_tmp15_ == SDL_QUIT) {
					_tmp13_ = TRUE;
				} else {
					SDL_Event _tmp16_ = {0};
					SDL_EventType _tmp17_ = 0;
					_tmp16_ = event;
					_tmp17_ = _tmp16_.type;
					_tmp13_ = _tmp17_ == SDL_KEYDOWN;
				}
				if (_tmp13_) {
					_tmp12_ = TRUE;
				} else {
					SDL_Event _tmp18_ = {0};
					SDL_EventType _tmp19_ = 0;
					_tmp18_ = event;
					_tmp19_ = _tmp18_.type;
					_tmp12_ = _tmp19_ == SDL_FINGERDOWN;
				}
				if (_tmp12_) {
					done = TRUE;
				}
			}
		}
		_tmp20_ = renderer;
		SDL_SetRenderDrawColor (_tmp20_, (guint8) 0x00, (guint8) 0x00, (guint8) 0xff, (guint8) 0xFF);
		_tmp21_ = renderer;
		SDL_RenderClear (_tmp21_);
		_tmp22_ = window;
		_tmp23_ = renderer;
		_tmp24_ = sprite;
		draw (_tmp22_, _tmp23_, _tmp24_);
		_tmp25_ = renderer;
		SDL_RenderPresent (_tmp25_);
	}
	result = 0;
	 (event);
	_sprite_release0 (sprite);
	_SDL_DestroyRenderer0 (renderer);
	_SDL_DestroyWindow0 (window);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return _vala_main (argv, argc);
}


Zed* zed_retain (Zed* self) {
	Zed* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->_retainCount), 1);
	result = self;
	return result;
}


void zed_release (Zed* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->_retainCount));
	if (_tmp0_) {
		zed_free (self);
	}
}


Zed* zed_new (const gchar* file, SDL_Renderer* renderer) {
	Zed* self;
	SDL_Surface* never = NULL;
	const gchar* _tmp0_ = NULL;
	SDL_Surface* _tmp1_ = NULL;
	g_return_val_if_fail (file != NULL, NULL);
	g_return_val_if_fail (renderer != NULL, NULL);
	self = g_slice_new0 (Zed);
	zed_instance_init (self);
	_tmp0_ = file;
	_tmp1_ = IMG_Load (_tmp0_);
	never = _tmp1_;
	_SDL_FreeSurface0 (never);
	return self;
}


static void zed_instance_init (Zed * self) {
	self->_retainCount = 1;
}


void zed_free (Zed* self) {
	g_slice_free (Zed, self);
}



