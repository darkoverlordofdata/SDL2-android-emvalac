/** updated by adriac */
/* Tween.c generated by valac 0.34.9, the Vala compiler
 * generated from Tween.vala, do not modify */

/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>

typedef struct _SdxMathTweenbase SdxMathTweenbase;

#define SDX_MATH_TYPE_TWEEN_KIND (sdx_math_tween_kind_get_type ())
typedef struct _Class Class;
typedef struct _SdxMathTweenAccessor SdxMathTweenAccessor;
typedef struct _SdxMathInterpolation SdxMathInterpolation;

#define SDX_MATH_TYPE_TIMELINE_MODES (sdx_math_timeline_modes_get_type ())
typedef struct _SdxMathTweenManager SdxMathTweenManager;
typedef SdxMathTweenbase SdxMathTween;
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
// symtbl.1 sdx_math_tweenbase
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
void sdx_math_tweenbase_free (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
#define _sdx_math_tweenbase_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_tweenbase_release (var), NULL)))
typedef SdxMathInterpolation SdxMathInterpolationQuadInOut;

#define SDX_MATH_TWEENBASE_TYPE_TWEEN_CALLBACK (sdx_math_tweenbase_tween_callback_get_type ())
typedef struct _Klass Klass;
// symtbl.1 klass
void klass_release (Klass* self);
void klass_free (Klass* self);
Klass* klass_retain (Klass* self);
#define _klass_release0(var) ((var == NULL) ? NULL : (var = (klass_release (var), NULL)))
// symtbl.1 sdx_math_interpolation
void sdx_math_interpolation_release (SdxMathInterpolation* self);
void sdx_math_interpolation_free (SdxMathInterpolation* self);
SdxMathInterpolation* sdx_math_interpolation_retain (SdxMathInterpolation* self);
#define _sdx_math_interpolation_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_interpolation_release (var), NULL)))
typedef struct _Block25Data Block25Data;
// symtbl.1 sdx_math_tween_accessor
void sdx_math_tween_accessor_release (SdxMathTweenAccessor* self);
void sdx_math_tween_accessor_free (SdxMathTweenAccessor* self);
SdxMathTweenAccessor* sdx_math_tween_accessor_retain (SdxMathTweenAccessor* self);
#define _sdx_math_tween_accessor_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_tween_accessor_release (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

typedef enum  {
	SDX_MATH_TWEEN_KIND_TWEEN,
	SDX_MATH_TWEEN_KIND_TIMELINE
} SdxMathTweenKind;

typedef void (*SdxMathTweenCallbackOnEvent) (gint type, SdxMathTweenbase* source, void* user_data);
typedef enum  {
	SDX_MATH_TIMELINE_MODES_SEQUENCE,
	SDX_MATH_TIMELINE_MODES_PARALLEL
} SdxMathTimelineModes;

typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenReset) (void* user_data);
typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenBuild) (void* user_data);
typedef void (*SdxMathTweenbaseTweenFree) (void* user_data);
typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenStart) (SdxMathTweenManager* manager, void* user_data);
typedef void (*SdxMathTweenbaseTweenForceStartValues) (void* user_data);
typedef void (*SdxMathTweenbaseTweenForceEndValues) (void* user_data);
typedef gboolean (*SdxMathTweenbaseTweenContainsTarget) (void* target, gint tweenType, void* user_data);
typedef void (*SdxMathTweenbaseTweenInitializeOverride) (void* user_data);
typedef void (*SdxMathTweenbaseTweenUpdateOverride) (gint step, gint lastStep, gboolean isIterationStep, gfloat delta, void* user_data);
struct _SdxMathTweenbase {
	gint ref_count;
	SdxMathTweenKind kind;
	gint step;
	gint repeatCnt;
	gboolean isIterationStep;
	gboolean isYoyo;
	gfloat delay;
	gfloat duration;
	gfloat repeatDelay;
	gfloat currentTime;
	gfloat deltaTime;
	gboolean isStarted;
	gboolean isInitialized;
	gboolean isFinished;
	gboolean isKilled;
	gboolean isPaused;
	SdxMathTweenCallbackOnEvent callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
	gint callbackTriggers;
	void* userData;
	gboolean isAutoRemoveEnabled;
	gboolean isAutoStartEnabled;
	void* target;
	Class* targetClass;
	SdxMathTweenAccessor* accessor;
	gint type;
	SdxMathInterpolation* equation;
	gboolean isFrom;
	gboolean isRelative;
	gint combinedAttrsCnt;
	gint waypointsCnt;
	gfloat* startValues;
	gint startValues_length1;
	gfloat* targetValues;
	gint targetValues_length1;
	gfloat* accessorBuffer;
	gint accessorBuffer_length1;
	GPtrArray* children;
	SdxMathTweenbase* current;
	SdxMathTweenbase* parent;
	SdxMathTimelineModes mode;
	gboolean isBuilt;
	SdxMathTweenbaseTweenReset Reset;
	gpointer Reset_target;
	GDestroyNotify Reset_target_destroy_notify;
	SdxMathTweenbaseTweenBuild Build;
	gpointer Build_target;
	GDestroyNotify Build_target_destroy_notify;
	SdxMathTweenbaseTweenFree Free;
	gpointer Free_target;
	GDestroyNotify Free_target_destroy_notify;
	SdxMathTweenbaseTweenStart Start;
	gpointer Start_target;
	GDestroyNotify Start_target_destroy_notify;
	SdxMathTweenbaseTweenForceStartValues ForceStartValues;
	gpointer ForceStartValues_target;
	GDestroyNotify ForceStartValues_target_destroy_notify;
	SdxMathTweenbaseTweenForceEndValues ForceEndValues;
	gpointer ForceEndValues_target;
	GDestroyNotify ForceEndValues_target_destroy_notify;
	SdxMathTweenbaseTweenContainsTarget ContainsTarget;
	gpointer ContainsTarget_target;
	GDestroyNotify ContainsTarget_target_destroy_notify;
	SdxMathTweenbaseTweenInitializeOverride InitializeOverride;
	gpointer InitializeOverride_target;
	GDestroyNotify InitializeOverride_target_destroy_notify;
	SdxMathTweenbaseTweenUpdateOverride UpdateOverride;
	gpointer UpdateOverride_target;
	GDestroyNotify UpdateOverride_target_destroy_notify;
};

typedef enum  {
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BEGIN = 0x01,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_START = 0x02,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_END = 0x04,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_COMPLETE = 0x08,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_BEGIN = 0x10,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_START = 0x20,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_END = 0x40,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_COMPLETE = 0x80,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY_FORWARD = 0x0F,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY_BACKWARD = 0xF0,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY = 0xFF
} SdxMathTweenbaseTweenCallback;

typedef enum  {
	SDX_EXCEPTION_IllegalArgumentException,
	SDX_EXCEPTION_RuntimeException
} SdxException;
#define SDX_EXCEPTION sdx_exception_quark ()
struct _Klass {
	gint ref_count;
	Class* klass;
};

struct _Block25Data {
	int _ref_count_;
	SdxMathTween* self;
	SdxMathTweenbaseTweenReset Reset_;
	gpointer Reset__target;
	GDestroyNotify Reset__target_destroy_notify;
};

typedef gint (*SdxMathTweenAccessorGetValues) (void* target, gint tweenType, gfloat** returnValues, int* returnValues_length1, void* user_data);
typedef void (*SdxMathTweenAccessorSetValues) (void* target, gint tweenType, gfloat** newValues, int* newValues_length1, void* user_data);
struct _SdxMathTweenAccessor {
	gint ref_count;
	SdxMathTweenAccessorGetValues GetValues;
	gpointer GetValues_target;
	GDestroyNotify GetValues_target_destroy_notify;
	SdxMathTweenAccessorSetValues SetValues;
	gpointer SetValues_target;
	GDestroyNotify SetValues_target_destroy_notify;
};

typedef gfloat (*SdxMathInterpolationInterpolationApply) (gfloat a, void* user_data);
struct _SdxMathInterpolation {
	gint ref_count;
	SdxMathInterpolationInterpolationApply Apply;
	gpointer Apply_target;
	GDestroyNotify Apply_target_destroy_notify;
};


extern GPtrArray* sdx_math_tweenbase_pool;
extern GHashTable* sdx_math_tweenbase_registeredAccessors;
extern gint sdx_math_tweenbase_combinedAttrsLimit;
extern gint sdx_math_tweenbase_waypointsLimit;
extern SdxMathInterpolationQuadInOut* sdx_math_interpolation_quadInOut;

void sdx_math_tweenbase_free (SdxMathTweenbase* self);
GType sdx_math_tween_kind_get_type (void) G_GNUC_CONST;
void class_free (Class* self);
void sdx_math_tween_accessor_free (SdxMathTweenAccessor* self);
void sdx_math_interpolation_free (SdxMathInterpolation* self);
GType sdx_math_timeline_modes_get_type (void) G_GNUC_CONST;
void sdx_math_tween_manager_free (SdxMathTweenManager* self);
#define SDX_MATH_TWEEN_INFINITY -1
void sdx_math_tween_Init (void);
// symtbl.2 sdx_math_tweenbase
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
void sdx_math_tweenbase_free (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
static void _sdx_math_tweenbase_release0_ (gpointer var);
// symtbl.2 sdx_math_tween_accessor
void sdx_math_tween_accessor_release (SdxMathTweenAccessor* self);
void sdx_math_tween_accessor_free (SdxMathTweenAccessor* self);
SdxMathTweenAccessor* sdx_math_tween_accessor_retain (SdxMathTweenAccessor* self);
static void _sdx_math_tween_accessor_release0_ (gpointer var);
void sdx_math_tween_SetCombinedAttributesLimit (gint limit);
void sdx_math_tween_SetWaypointsLimit (gint limit);
void sdx_math_tween_RegisterAccessor (void* someClass, SdxMathTweenAccessor* defaultAccessor);
SdxMathTweenAccessor* sdx_math_tween_GetRegisteredAccessor (void* someClass);
SdxMathTween* sdx_math_tween_To (void* target, gint tweenType, gfloat duration);
// symtbl.3 SdxMathTween / sdx_math_tween
SdxMathTween* sdx_math_tween_retain (SdxMathTween* self);
void sdx_math_tween_release (SdxMathTween* self);
SdxMathTween* sdx_math_tween_new (void);
void sdx_math_tween_Setup (SdxMathTween* self, void* target, gint tweenType, gfloat duration);
SdxMathTween* sdx_math_tween_Ease (SdxMathTween* self, SdxMathInterpolation* easeEquation);
SdxMathTween* sdx_math_tween_From (void* target, gint tweenType, gfloat duration);
SdxMathTween* sdx_math_tween_Set (void* target, gint tweenType);
SdxMathTween* sdx_math_tween_Call (SdxMathTweenCallbackOnEvent callback, void* callback_target);
SdxMathTweenbase* sdx_math_tweenbase_SetCallback (SdxMathTweenbase* self, SdxMathTweenCallbackOnEvent callback, void* callback_target);
SdxMathTweenbase* sdx_math_tweenbase_SetCallbackTriggers (SdxMathTweenbase* self, gint flags);
GType sdx_math_tweenbase_tween_callback_get_type (void) G_GNUC_CONST;
SdxMathTween* sdx_math_tween_Mark (void);
// symtbl.3 SdxMathTweenbase / sdx_math_tweenbase
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_new (void);
void sdx_math_tween_Overrides (SdxMathTween* self);
GQuark sdx_exception_quark (void);
void klass_free (Klass* self);
SdxMathTween* sdx_math_tween_Target (SdxMathTween* self, gfloat* targetValues, int targetValues_length1);
SdxMathTween* sdx_math_tween_TargetRelative (SdxMathTween* self, gfloat* targetValues, int targetValues_length1);
gboolean sdx_math_tweenbase_IsInitialized (SdxMathTweenbase* self);
static Block25Data* block25_data_ref (Block25Data* _data25_);
static void block25_data_unref (void * _userdata_);
static SdxMathTweenbase* __lambda117_ (Block25Data* _data25_);
static SdxMathTweenbase* ___lambda117__sdx_math_tweenbase_tween_reset (gpointer self);
static SdxMathTweenbase* __lambda118_ (SdxMathTween* self);
static SdxMathTweenbase* ___lambda118__sdx_math_tweenbase_tween_build (gpointer self);
static void __lambda119_ (SdxMathTween* self);
static void ___lambda119__sdx_math_tweenbase_tween_initialize_override (gpointer self);
static void __lambda120_ (SdxMathTween* self, gint step, gint lastStep, gboolean isIterationStep, gfloat delta);
gboolean sdx_math_tweenbase_IsReverse (SdxMathTweenbase* self, gint step);
gfloat sdx_math_tweenbase_GetCurrentTime (SdxMathTweenbase* self);
static void ___lambda120__sdx_math_tweenbase_tween_update_override (gint step, gint lastStep, gboolean isIterationStep, gfloat delta, gpointer self);
static void __lambda121_ (SdxMathTween* self);
static void ___lambda121__sdx_math_tweenbase_tween_force_start_values (gpointer self);
static void __lambda122_ (SdxMathTween* self);
static void ___lambda122__sdx_math_tweenbase_tween_force_end_values (gpointer self);
static gboolean __lambda123_ (SdxMathTween* self, void* target, gint tweenType);
static gboolean ___lambda123__sdx_math_tweenbase_tween_contains_target (void* target, gint tweenType, gpointer self);


// symtbl.2 sdx_math_tweenbase
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
void sdx_math_tweenbase_free (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
static void _sdx_math_tweenbase_release0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (sdx_math_tweenbase_release (var), NULL));
}


// symtbl.2 sdx_math_tween_accessor
void sdx_math_tween_accessor_release (SdxMathTweenAccessor* self);
void sdx_math_tween_accessor_free (SdxMathTweenAccessor* self);
SdxMathTweenAccessor* sdx_math_tween_accessor_retain (SdxMathTweenAccessor* self);
static void _sdx_math_tween_accessor_release0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (sdx_math_tween_accessor_release (var), NULL));
}


void sdx_math_tween_Init (void) {
	GPtrArray* _tmp0_ = NULL;
	GHashTable* _tmp1_ = NULL;
	_tmp0_ = g_ptr_array_new_full ((guint) 0, _sdx_math_tweenbase_release0_);
	_g_ptr_array_unref0 (sdx_math_tweenbase_pool);
	sdx_math_tweenbase_pool = _tmp0_;
	_tmp1_ = g_hash_table_new_full (NULL, NULL, NULL, _sdx_math_tween_accessor_release0_);
	_g_hash_table_unref0 (sdx_math_tweenbase_registeredAccessors);
	sdx_math_tweenbase_registeredAccessors = _tmp1_;
}


/**
         * Changes the limit for combined attributes. Defaults to 3 to reduce
         * memory footprint.
         */
void sdx_math_tween_SetCombinedAttributesLimit (gint limit) {
	gint _tmp0_ = 0;
	_tmp0_ = limit;
	sdx_math_tweenbase_combinedAttrsLimit = _tmp0_;
}


/**
         * Changes the limit of allowed waypoints for each tween. Defaults to 0 to
         * reduce memory footprint.
         */
void sdx_math_tween_SetWaypointsLimit (gint limit) {
	gint _tmp0_ = 0;
	_tmp0_ = limit;
	sdx_math_tweenbase_waypointsLimit = _tmp0_;
}


/**
         * Registers an accessor with the class of an object. This accessor will be
         * used by tweens applied to every objects implementing the registered
         * class, or inheriting from it.
         *
         * @param someClass An object class.
         * @param defaultAccessor The accessor that will be used to tween any
         * object of klass "someClass".x`
         */
static gpointer _sdx_math_tween_accessor_retain0 (gpointer self) {
	return self ? sdx_math_tween_accessor_retain (self) : NULL;
}


void sdx_math_tween_RegisterAccessor (void* someClass, SdxMathTweenAccessor* defaultAccessor) {
	GHashTable* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	SdxMathTweenAccessor* _tmp2_ = NULL;
	SdxMathTweenAccessor* _tmp3_ = NULL;
	g_return_if_fail (defaultAccessor != NULL);
	_tmp0_ = sdx_math_tweenbase_registeredAccessors;
	_tmp1_ = someClass;
	_tmp2_ = defaultAccessor;
	_tmp3_ = _sdx_math_tween_accessor_retain0 (_tmp2_);
	g_hash_table_insert (_tmp0_, _tmp1_, _tmp3_);
}


/**
         * Gets the registered TweenAccessor associated with the given object class.
         *
         * @param someClass An object class.
         */
SdxMathTweenAccessor* sdx_math_tween_GetRegisteredAccessor (void* someClass) {
	SdxMathTweenAccessor* result = NULL;
	GHashTable* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	SdxMathTweenAccessor* _tmp3_ = NULL;
	_tmp0_ = sdx_math_tweenbase_registeredAccessors;
	_tmp1_ = someClass;
	_tmp2_ = g_hash_table_lookup (_tmp0_, _tmp1_);
	_tmp3_ = _sdx_math_tween_accessor_retain0 ((SdxMathTweenAccessor*) _tmp2_);
	result = _tmp3_;
	return result;
}


/**
         * Factory creating a new standard interpolation. This is the most common
         * type of interpolation. The starting values are retrieved automatically
         * after the delay (if any).
         *
         * ''You need to set the target values of the interpolation by using one of the target() methods''. 
         * The interpolation will run from the
         * starting values to these target values.
         *
         * The common use of Tweens is "fire-and-forget": you do not need to care
         * for tweens once you added them to a TweenManager, they will be updated
         * automatically, and cleaned once finished. Common call:
         *
         * {{{
         * Tween.To(myObject, POSITION, 1.0f)
         *      .Target({ 50, 70 })
         *      .Ease(Interpolation.QuadInOut)
         *      .Start(myManager);
         * }}}
         *
         * Several options such as delay, repetitions and callbacks can be added to
         * the tween.
         *
         * @param target The target object of the interpolation.
         * @param tweenType The desired type of interpolation.
         * @param duration The duration of the interpolation, in milliseconds.
         * @return The generated Tween.
         */
static gboolean g_ptr_array_IsEmpty (GPtrArray* self) {
	gboolean result = FALSE;
	guint _tmp0_ = 0U;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->len;
	result = _tmp0_ == ((guint) 0);
	return result;
}


static gpointer g_ptr_array_Pop (GPtrArray* self) {
	gpointer result = NULL;
	gpointer item = NULL;
	guint _tmp0_ = 0U;
	gconstpointer _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->len;
	_tmp1_ = g_ptr_array_index (self, _tmp0_ - 1);
	item = _tmp1_;
	_tmp2_ = self->len;
	g_ptr_array_remove_index (self, _tmp2_ - 1);
	result = item;
	return result;
}


static gpointer _sdx_math_tweenbase_retain0 (gpointer self) {
	return self ? sdx_math_tweenbase_retain (self) : NULL;
}


SdxMathTween* sdx_math_tween_To (void* target, gint tweenType, gfloat duration) {
	SdxMathTween* result = NULL;
	SdxMathTween* _tmp0_ = NULL;
	GPtrArray* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	SdxMathTween* tween = NULL;
	SdxMathTween* _tmp9_ = NULL;
	void* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gfloat _tmp12_ = 0.0F;
	SdxMathInterpolationQuadInOut* _tmp13_ = NULL;
	SdxMathTween* _tmp14_ = NULL;
	SdxMathTween* _tmp15_ = NULL;
	_tmp1_ = sdx_math_tweenbase_pool;
	_tmp2_ = g_ptr_array_IsEmpty (_tmp1_);
	if (_tmp2_) {
		SdxMathTween* _tmp3_ = NULL;
		_tmp3_ = sdx_math_tween_new ();
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = _tmp3_;
	} else {
		GPtrArray* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		SdxMathTweenbase* _tmp6_ = NULL;
		SdxMathTweenbaseTweenReset _tmp7_ = NULL;
		void* _tmp7__target = NULL;
		SdxMathTweenbase* _tmp8_ = NULL;
		_tmp4_ = sdx_math_tweenbase_pool;
		_tmp5_ = g_ptr_array_Pop (_tmp4_);
		_tmp6_ = (SdxMathTweenbase*) _tmp5_;
		_tmp7_ = _tmp6_->Reset;
		_tmp7__target = _tmp6_->Reset_target;
		_tmp8_ = _tmp7_ (_tmp7__target);
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = (SdxMathTween*) _tmp8_;
		_sdx_math_tweenbase_release0 (_tmp6_);
	}
	_tmp9_ = _sdx_math_tweenbase_retain0 (_tmp0_);
	tween = _tmp9_;
	_tmp10_ = target;
	_tmp11_ = tweenType;
	_tmp12_ = duration;
	sdx_math_tween_Setup (tween, _tmp10_, _tmp11_, _tmp12_);
	_tmp13_ = sdx_math_interpolation_quadInOut;
	_tmp14_ = sdx_math_tween_Ease (tween, (SdxMathInterpolation*) _tmp13_);
	_tmp15_ = _tmp14_;
	_sdx_math_tweenbase_release0 (_tmp15_);
	result = tween;
	_sdx_math_tweenbase_release0 (_tmp0_);
	return result;
}


/**
         * Factory creating a new reversed interpolation. The ending values are
         * retrieved automatically after the delay (if any).
         *
         * ''You need to set the starting values of the interpolation by using one of the target() methods''. The interpolation will run from the
         * starting values to these target values.
         *
         * The common use of Tweens is "fire-and-forget": you do not need to care
         * for tweens once you added them to a TweenManager, they will be updated
         * automatically, and cleaned once finished. Common call:
         *
         * {{{
         * Tween.From(myObject, POSITION, 1.0f)
         *      .Target({ 0, 0 })
         *      .Ease(Interpolation.QuadInOut)
         *      .Start(myManager);
         * }}}
         *
         * Several options such as delay, repetitions and callbacks can be added to
         * the tween.
         *
         * @param target The target object of the interpolation.
         * @param tweenType The desired type of interpolation.
         * @param duration The duration of the interpolation, in milliseconds.
         * @return The generated Tween.
         */
SdxMathTween* sdx_math_tween_From (void* target, gint tweenType, gfloat duration) {
	SdxMathTween* result = NULL;
	SdxMathTween* _tmp0_ = NULL;
	GPtrArray* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	SdxMathTween* tween = NULL;
	SdxMathTween* _tmp9_ = NULL;
	void* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gfloat _tmp12_ = 0.0F;
	SdxMathInterpolationQuadInOut* _tmp13_ = NULL;
	SdxMathTween* _tmp14_ = NULL;
	SdxMathTween* _tmp15_ = NULL;
	_tmp1_ = sdx_math_tweenbase_pool;
	_tmp2_ = g_ptr_array_IsEmpty (_tmp1_);
	if (_tmp2_) {
		SdxMathTween* _tmp3_ = NULL;
		_tmp3_ = sdx_math_tween_new ();
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = _tmp3_;
	} else {
		GPtrArray* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		SdxMathTweenbase* _tmp6_ = NULL;
		SdxMathTweenbaseTweenReset _tmp7_ = NULL;
		void* _tmp7__target = NULL;
		SdxMathTweenbase* _tmp8_ = NULL;
		_tmp4_ = sdx_math_tweenbase_pool;
		_tmp5_ = g_ptr_array_Pop (_tmp4_);
		_tmp6_ = (SdxMathTweenbase*) _tmp5_;
		_tmp7_ = _tmp6_->Reset;
		_tmp7__target = _tmp6_->Reset_target;
		_tmp8_ = _tmp7_ (_tmp7__target);
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = (SdxMathTween*) _tmp8_;
		_sdx_math_tweenbase_release0 (_tmp6_);
	}
	_tmp9_ = _sdx_math_tweenbase_retain0 (_tmp0_);
	tween = _tmp9_;
	_tmp10_ = target;
	_tmp11_ = tweenType;
	_tmp12_ = duration;
	sdx_math_tween_Setup (tween, _tmp10_, _tmp11_, _tmp12_);
	_tmp13_ = sdx_math_interpolation_quadInOut;
	_tmp14_ = sdx_math_tween_Ease (tween, (SdxMathInterpolation*) _tmp13_);
	_tmp15_ = _tmp14_;
	_sdx_math_tweenbase_release0 (_tmp15_);
	((SdxMathTweenbase*) tween)->isFrom = TRUE;
	result = tween;
	_sdx_math_tweenbase_release0 (_tmp0_);
	return result;
}


/**
         * Factory creating a new instantaneous interpolation (thus this is not
         * really an interpolation).
         *
         * ''You need to set the target values of the interpolation by using one of the target() methods''. The interpolation will set the target
         * attribute to these values after the delay (if any).
         *
         * The common use of Tweens is "fire-and-forget": you do not need to care
         * for tweens once you added them to a TweenManager, they will be updated
         * automatically, and cleaned once finished. Common call:
         *
         * {{{
         * Tween.Set(myObject, POSITION)
         *      .Target({ 50, 70 })
         *      .Delay(1.0f)
         *      .Start(myManager);
         * }}}
         *
         * Several options such as delay, repetitions and callbacks can be added to
         * the tween.
         *
         * @param target The target object of the interpolation.
         * @param tweenType The desired type of interpolation.
         * @return The generated Tween.
         */
SdxMathTween* sdx_math_tween_Set (void* target, gint tweenType) {
	SdxMathTween* result = NULL;
	SdxMathTween* _tmp0_ = NULL;
	GPtrArray* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	SdxMathTween* tween = NULL;
	SdxMathTween* _tmp9_ = NULL;
	void* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	SdxMathInterpolationQuadInOut* _tmp12_ = NULL;
	SdxMathTween* _tmp13_ = NULL;
	SdxMathTween* _tmp14_ = NULL;
	_tmp1_ = sdx_math_tweenbase_pool;
	_tmp2_ = g_ptr_array_IsEmpty (_tmp1_);
	if (_tmp2_) {
		SdxMathTween* _tmp3_ = NULL;
		_tmp3_ = sdx_math_tween_new ();
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = _tmp3_;
	} else {
		GPtrArray* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		SdxMathTweenbase* _tmp6_ = NULL;
		SdxMathTweenbaseTweenReset _tmp7_ = NULL;
		void* _tmp7__target = NULL;
		SdxMathTweenbase* _tmp8_ = NULL;
		_tmp4_ = sdx_math_tweenbase_pool;
		_tmp5_ = g_ptr_array_Pop (_tmp4_);
		_tmp6_ = (SdxMathTweenbase*) _tmp5_;
		_tmp7_ = _tmp6_->Reset;
		_tmp7__target = _tmp6_->Reset_target;
		_tmp8_ = _tmp7_ (_tmp7__target);
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = (SdxMathTween*) _tmp8_;
		_sdx_math_tweenbase_release0 (_tmp6_);
	}
	_tmp9_ = _sdx_math_tweenbase_retain0 (_tmp0_);
	tween = _tmp9_;
	_tmp10_ = target;
	_tmp11_ = tweenType;
	sdx_math_tween_Setup (tween, _tmp10_, _tmp11_, (gfloat) 0);
	_tmp12_ = sdx_math_interpolation_quadInOut;
	_tmp13_ = sdx_math_tween_Ease (tween, (SdxMathInterpolation*) _tmp12_);
	_tmp14_ = _tmp13_;
	_sdx_math_tweenbase_release0 (_tmp14_);
	result = tween;
	_sdx_math_tweenbase_release0 (_tmp0_);
	return result;
}


/**
         * Factory creating a new timer. The given callback will be triggered on
         * each iteration start, after the delay.
         *
         * The common use of Tweens is "fire-and-forget": you do not need to care
         * for tweens once you added them to a TweenManager, they will be updated
         * automatically, and cleaned once finished. Common call:
         *
         * {{{
         * Tween.Call(myCallback)
         *      .Delay(1.0f)
         *      .Tepeat(10, 1000)
         *      .Start(myManager);
         * }}}
         *
         * @param callback The callback that will be triggered on each iteration
         * start.
         * @return The generated Tween.
         * @see Tweenbase.TweenCallback
         */
SdxMathTween* sdx_math_tween_Call (SdxMathTweenCallbackOnEvent callback, void* callback_target) {
	SdxMathTween* result = NULL;
	SdxMathTween* _tmp0_ = NULL;
	GPtrArray* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	SdxMathTween* tween = NULL;
	SdxMathTween* _tmp9_ = NULL;
	SdxMathTweenCallbackOnEvent _tmp10_ = NULL;
	void* _tmp10__target = NULL;
	SdxMathTweenbase* _tmp11_ = NULL;
	SdxMathTweenbase* _tmp12_ = NULL;
	SdxMathTweenbase* _tmp13_ = NULL;
	SdxMathTweenbase* _tmp14_ = NULL;
	_tmp1_ = sdx_math_tweenbase_pool;
	_tmp2_ = g_ptr_array_IsEmpty (_tmp1_);
	if (_tmp2_) {
		SdxMathTween* _tmp3_ = NULL;
		_tmp3_ = sdx_math_tween_new ();
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = _tmp3_;
	} else {
		GPtrArray* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		SdxMathTweenbase* _tmp6_ = NULL;
		SdxMathTweenbaseTweenReset _tmp7_ = NULL;
		void* _tmp7__target = NULL;
		SdxMathTweenbase* _tmp8_ = NULL;
		_tmp4_ = sdx_math_tweenbase_pool;
		_tmp5_ = g_ptr_array_Pop (_tmp4_);
		_tmp6_ = (SdxMathTweenbase*) _tmp5_;
		_tmp7_ = _tmp6_->Reset;
		_tmp7__target = _tmp6_->Reset_target;
		_tmp8_ = _tmp7_ (_tmp7__target);
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = (SdxMathTween*) _tmp8_;
		_sdx_math_tweenbase_release0 (_tmp6_);
	}
	_tmp9_ = _sdx_math_tweenbase_retain0 (_tmp0_);
	tween = _tmp9_;
	sdx_math_tween_Setup (tween, NULL, -1, (gfloat) 0);
	_tmp10_ = callback;
	_tmp10__target = callback_target;
	_tmp11_ = sdx_math_tweenbase_SetCallback ((SdxMathTweenbase*) tween, _tmp10_, _tmp10__target);
	_tmp12_ = _tmp11_;
	_sdx_math_tweenbase_release0 (_tmp12_);
	_tmp13_ = sdx_math_tweenbase_SetCallbackTriggers ((SdxMathTweenbase*) tween, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_START);
	_tmp14_ = _tmp13_;
	_sdx_math_tweenbase_release0 (_tmp14_);
	result = tween;
	_sdx_math_tweenbase_release0 (_tmp0_);
	return result;
}


/**
         * Convenience method to create an empty tween. Such object is only useful
         * when placed inside animation sequences (see {@link Timeline}), in which
         * it may act as a beacon, so you can set a callback on it in order to
         * trigger some action at the right moment.
         *
         * @return The generated Tween.
         * @see Timeline
         */
SdxMathTween* sdx_math_tween_Mark (void) {
	SdxMathTween* result = NULL;
	SdxMathTween* _tmp0_ = NULL;
	GPtrArray* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	SdxMathTween* tween = NULL;
	SdxMathTween* _tmp9_ = NULL;
	_tmp1_ = sdx_math_tweenbase_pool;
	_tmp2_ = g_ptr_array_IsEmpty (_tmp1_);
	if (_tmp2_) {
		SdxMathTween* _tmp3_ = NULL;
		_tmp3_ = sdx_math_tween_new ();
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = _tmp3_;
	} else {
		GPtrArray* _tmp4_ = NULL;
		gpointer _tmp5_ = NULL;
		SdxMathTweenbase* _tmp6_ = NULL;
		SdxMathTweenbaseTweenReset _tmp7_ = NULL;
		void* _tmp7__target = NULL;
		SdxMathTweenbase* _tmp8_ = NULL;
		_tmp4_ = sdx_math_tweenbase_pool;
		_tmp5_ = g_ptr_array_Pop (_tmp4_);
		_tmp6_ = (SdxMathTweenbase*) _tmp5_;
		_tmp7_ = _tmp6_->Reset;
		_tmp7__target = _tmp6_->Reset_target;
		_tmp8_ = _tmp7_ (_tmp7__target);
		_sdx_math_tweenbase_release0 (_tmp0_);
		_tmp0_ = (SdxMathTween*) _tmp8_;
		_sdx_math_tweenbase_release0 (_tmp6_);
	}
	_tmp9_ = _sdx_math_tweenbase_retain0 (_tmp0_);
	tween = _tmp9_;
	sdx_math_tween_Setup (tween, NULL, -1, (gfloat) 0);
	result = tween;
	_sdx_math_tweenbase_release0 (_tmp0_);
	return result;
}


// symtbl.3 SdxMathTween / sdx_math_tween
SdxMathTween* sdx_math_tween_retain (SdxMathTween* self);
void sdx_math_tween_release (SdxMathTween* self);
SdxMathTween* sdx_math_tween_new (void) {
	SdxMathTween* self;
	SdxMathTweenbaseTweenReset _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	SdxMathTweenbase* _tmp1_ = NULL;
	SdxMathTweenbase* _tmp2_ = NULL;
	self = (SdxMathTween*) sdx_math_tweenbase_new ();
	((SdxMathTweenbase*) self)->kind = SDX_MATH_TWEEN_KIND_TWEEN;
	sdx_math_tween_Overrides (self);
	_tmp0_ = ((SdxMathTweenbase*) self)->Reset;
	_tmp0__target = ((SdxMathTweenbase*) self)->Reset_target;
	_tmp1_ = _tmp0_ (_tmp0__target);
	_tmp2_ = _tmp1_;
	_sdx_math_tweenbase_release0 (_tmp2_);
	return self;
}


static gpointer _klass_retain0 (gpointer self) {
	return self ? klass_retain (self) : NULL;
}


void sdx_math_tween_Setup (SdxMathTween* self, void* target, gint tweenType, gfloat duration) {
	gfloat _tmp0_ = 0.0F;
	void* _tmp2_ = NULL;
	Klass* tweenable = NULL;
	void* _tmp3_ = NULL;
	Klass* _tmp4_ = NULL;
	Class* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gfloat _tmp7_ = 0.0F;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = duration;
	if (_tmp0_ < ((gfloat) 0)) {
		GError* _tmp1_ = NULL;
		_tmp1_ = g_error_new_literal (SDX_EXCEPTION, SDX_EXCEPTION_RuntimeException, "Duration can't be negative");
		_inner_error_ = _tmp1_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp2_ = target;
	((SdxMathTweenbase*) self)->target = _tmp2_;
	_tmp3_ = target;
	_tmp4_ = _klass_retain0 ((Klass*) _tmp3_);
	tweenable = _tmp4_;
	_tmp5_ = tweenable->klass;
	((SdxMathTweenbase*) self)->targetClass = _tmp5_;
	_tmp6_ = tweenType;
	((SdxMathTweenbase*) self)->type = _tmp6_;
	_tmp7_ = duration;
	((SdxMathTweenbase*) self)->duration = _tmp7_;
	_klass_release0 (tweenable);
}


/**
         * Sets the easing equation of the tween. Existing equations are located in
         * //aurelienribon.tweenengine.equations// package, but you can of course
         * implement your owns, see {@link Interpolation}. You can also use the
         * {@link Interpolation} static instances to quickly access all the
         * equations. Default equation is Interpolation.QuadInOut.
         *
         * ''Proposed equations are:''
         * 
         *  || Linear.INOUT ||
         *  || Quad.IN || OUT || INOUT ||
         *  || Cubic.IN || OUT || INOUT ||
         *  || Quart.IN || OUT || INOUT ||
         *  || Quint.IN || OUT || INOUT ||
         *  || Circ.IN || OUT || INOUT ||
         *  || Sine.IN || OUT || INOUT ||
         *  || Expo.IN || OUT || INOUT ||
         *  || Back.IN || OUT || INOUT ||
         *  || Bounce.IN || OUT || INOUT ||
         *  || Elastic.IN || OUT || INOUT ||
         *
         * @return The current tween, for chaining instructions.
         * @see Interpolation
         * @see Interpolation
         */
static gpointer _sdx_math_interpolation_retain0 (gpointer self) {
	return self ? sdx_math_interpolation_retain (self) : NULL;
}


SdxMathTween* sdx_math_tween_Ease (SdxMathTween* self, SdxMathInterpolation* easeEquation) {
	SdxMathTween* result = NULL;
	SdxMathInterpolation* _tmp0_ = NULL;
	SdxMathInterpolation* _tmp1_ = NULL;
	SdxMathTween* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (easeEquation != NULL, NULL);
	_tmp0_ = easeEquation;
	_tmp1_ = _sdx_math_interpolation_retain0 (_tmp0_);
	_sdx_math_interpolation_release0 (((SdxMathTweenbase*) self)->equation);
	((SdxMathTweenbase*) self)->equation = _tmp1_;
	_tmp2_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp2_;
	return result;
}


/**
         * Sets the target values of the interpolation. The interpolation will run
         * from the ''values at start time (after the delay, if any)'' to these
         * target values.
         *
         * To sum-up:
         * 
         *  * start values: values at start time, after delay
         *  * end values: params
         *
         * @param targetValues The target values of the interpolation.
         * @return The current tween, for chaining instructions.
         */
SdxMathTween* sdx_math_tween_Target (SdxMathTween* self, gfloat* targetValues, int targetValues_length1) {
	SdxMathTween* result = NULL;
	gfloat* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gfloat* _tmp1_ = NULL;
	SdxMathTween* _tmp12_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = targetValues;
	_tmp0__length1 = targetValues_length1;
	_tmp1_ = g_new0 (gfloat, _tmp0__length1);
	((SdxMathTweenbase*) self)->targetValues = (g_free (((SdxMathTweenbase*) self)->targetValues), NULL);
	((SdxMathTweenbase*) self)->targetValues = _tmp1_;
	((SdxMathTweenbase*) self)->targetValues_length1 = _tmp0__length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				gfloat* _tmp5_ = NULL;
				gint _tmp5__length1 = 0;
				gfloat* _tmp6_ = NULL;
				gint _tmp6__length1 = 0;
				gint _tmp7_ = 0;
				gfloat* _tmp8_ = NULL;
				gint _tmp8__length1 = 0;
				gint _tmp9_ = 0;
				gfloat _tmp10_ = 0.0F;
				gfloat _tmp11_ = 0.0F;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = targetValues;
				_tmp5__length1 = targetValues_length1;
				if (!(_tmp4_ < _tmp5__length1)) {
					break;
				}
				_tmp6_ = ((SdxMathTweenbase*) self)->targetValues;
				_tmp6__length1 = ((SdxMathTweenbase*) self)->targetValues_length1;
				_tmp7_ = i;
				_tmp8_ = targetValues;
				_tmp8__length1 = targetValues_length1;
				_tmp9_ = i;
				_tmp10_ = _tmp8_[_tmp9_];
				_tmp6_[_tmp7_] = _tmp10_;
				_tmp11_ = _tmp6_[_tmp7_];
			}
		}
	}
	_tmp12_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp12_;
	return result;
}


/**
         * Sets the target values of the interpolation, relatively to the 
         * ''values at start time (after the delay, if any)''.
         *
         * To sum-up:
         * 
         *  * start values: values at start time, after delay
         *  * end values: params + values at start time, after delay
         *
         * @param targetValues The relative target values of the interpolation.
         * @return The current tween, for chaining instructions.
         */
SdxMathTween* sdx_math_tween_TargetRelative (SdxMathTween* self, gfloat* targetValues, int targetValues_length1) {
	SdxMathTween* result = NULL;
	gfloat* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gfloat* _tmp1_ = NULL;
	SdxMathTween* _tmp20_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	((SdxMathTweenbase*) self)->isRelative = TRUE;
	_tmp0_ = targetValues;
	_tmp0__length1 = targetValues_length1;
	_tmp1_ = g_new0 (gfloat, _tmp0__length1);
	((SdxMathTweenbase*) self)->targetValues = (g_free (((SdxMathTweenbase*) self)->targetValues), NULL);
	((SdxMathTweenbase*) self)->targetValues = _tmp1_;
	((SdxMathTweenbase*) self)->targetValues_length1 = _tmp0__length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				gfloat* _tmp5_ = NULL;
				gint _tmp5__length1 = 0;
				gfloat _tmp6_ = 0.0F;
				gboolean _tmp7_ = FALSE;
				gfloat* _tmp17_ = NULL;
				gint _tmp17__length1 = 0;
				gint _tmp18_ = 0;
				gfloat _tmp19_ = 0.0F;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = targetValues;
				_tmp5__length1 = targetValues_length1;
				if (!(_tmp4_ < _tmp5__length1)) {
					break;
				}
				_tmp7_ = sdx_math_tweenbase_IsInitialized ((SdxMathTweenbase*) self);
				if (_tmp7_) {
					gfloat* _tmp8_ = NULL;
					gint _tmp8__length1 = 0;
					gint _tmp9_ = 0;
					gfloat _tmp10_ = 0.0F;
					gfloat* _tmp11_ = NULL;
					gint _tmp11__length1 = 0;
					gint _tmp12_ = 0;
					gfloat _tmp13_ = 0.0F;
					_tmp8_ = targetValues;
					_tmp8__length1 = targetValues_length1;
					_tmp9_ = i;
					_tmp10_ = _tmp8_[_tmp9_];
					_tmp11_ = ((SdxMathTweenbase*) self)->startValues;
					_tmp11__length1 = ((SdxMathTweenbase*) self)->startValues_length1;
					_tmp12_ = i;
					_tmp13_ = _tmp11_[_tmp12_];
					_tmp6_ = _tmp10_ + _tmp13_;
				} else {
					gfloat* _tmp14_ = NULL;
					gint _tmp14__length1 = 0;
					gint _tmp15_ = 0;
					gfloat _tmp16_ = 0.0F;
					_tmp14_ = targetValues;
					_tmp14__length1 = targetValues_length1;
					_tmp15_ = i;
					_tmp16_ = _tmp14_[_tmp15_];
					_tmp6_ = _tmp16_;
				}
				_tmp17_ = ((SdxMathTweenbase*) self)->targetValues;
				_tmp17__length1 = ((SdxMathTweenbase*) self)->targetValues_length1;
				_tmp18_ = i;
				_tmp17_[_tmp18_] = _tmp6_;
				_tmp19_ = _tmp17_[_tmp18_];
			}
		}
	}
	_tmp20_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp20_;
	return result;
}


static Block25Data* block25_data_ref (Block25Data* _data25_) {
	g_atomic_int_inc (&_data25_->_ref_count_);
	return _data25_;
}


static void block25_data_unref (void * _userdata_) {
	Block25Data* _data25_;
	_data25_ = (Block25Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data25_->_ref_count_)) {
		SdxMathTween* self;
		self = _data25_->self;
		(_data25_->Reset__target_destroy_notify == NULL) ? NULL : (_data25_->Reset__target_destroy_notify (_data25_->Reset__target), NULL);
		_data25_->Reset_ = NULL;
		_data25_->Reset__target = NULL;
		_data25_->Reset__target_destroy_notify = NULL;
		_sdx_math_tweenbase_release0 (self);
		g_slice_free (Block25Data, _data25_);
	}
}


static SdxMathTweenbase* __lambda117_ (Block25Data* _data25_) {
	SdxMathTween* self;
	SdxMathTweenbase* result = NULL;
	SdxMathTweenbase* _tmp0_ = NULL;
	SdxMathTweenbase* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_ = 0;
	gfloat* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	gint _tmp5_ = 0;
	SdxMathTweenbase* _tmp8_ = NULL;
	self = _data25_->self;
	_tmp0_ = _data25_->Reset_ (_data25_->Reset__target);
	_tmp1_ = _tmp0_;
	_sdx_math_tweenbase_release0 (_tmp1_);
	((SdxMathTweenbase*) self)->target = NULL;
	((SdxMathTweenbase*) self)->targetClass = NULL;
	_sdx_math_tween_accessor_release0 (((SdxMathTweenbase*) self)->accessor);
	((SdxMathTweenbase*) self)->accessor = NULL;
	((SdxMathTweenbase*) self)->type = -1;
	_sdx_math_interpolation_release0 (((SdxMathTweenbase*) self)->equation);
	((SdxMathTweenbase*) self)->equation = NULL;
	((SdxMathTweenbase*) self)->isRelative = FALSE;
	_tmp2_ = ((SdxMathTweenbase*) self)->isRelative;
	((SdxMathTweenbase*) self)->isFrom = _tmp2_;
	((SdxMathTweenbase*) self)->waypointsCnt = 0;
	_tmp3_ = ((SdxMathTweenbase*) self)->waypointsCnt;
	((SdxMathTweenbase*) self)->combinedAttrsCnt = _tmp3_;
	_tmp4_ = ((SdxMathTweenbase*) self)->accessorBuffer;
	_tmp4__length1 = ((SdxMathTweenbase*) self)->accessorBuffer_length1;
	_tmp5_ = sdx_math_tweenbase_combinedAttrsLimit;
	if (_tmp4__length1 != _tmp5_) {
		gint _tmp6_ = 0;
		gfloat* _tmp7_ = NULL;
		_tmp6_ = sdx_math_tweenbase_combinedAttrsLimit;
		_tmp7_ = g_new0 (gfloat, _tmp6_);
		((SdxMathTweenbase*) self)->accessorBuffer = (g_free (((SdxMathTweenbase*) self)->accessorBuffer), NULL);
		((SdxMathTweenbase*) self)->accessorBuffer = _tmp7_;
		((SdxMathTweenbase*) self)->accessorBuffer_length1 = _tmp6_;
	}
	_tmp8_ = _sdx_math_tweenbase_retain0 ((SdxMathTweenbase*) self);
	result = _tmp8_;
	return result;
}


static SdxMathTweenbase* ___lambda117__sdx_math_tweenbase_tween_reset (gpointer self) {
	SdxMathTweenbase* result;
	result = __lambda117_ (self);
	return result;
}


static SdxMathTweenbase* __lambda118_ (SdxMathTween* self) {
	SdxMathTweenbase* result = NULL;
	void* _tmp0_ = NULL;
	GHashTable* _tmp2_ = NULL;
	Class* _tmp3_ = NULL;
	gconstpointer _tmp4_ = NULL;
	SdxMathTweenAccessor* _tmp5_ = NULL;
	SdxMathTweenAccessor* _tmp6_ = NULL;
	gint _tmp13_ = 0;
	gint _tmp14_ = 0;
	SdxMathTweenbase* _tmp16_ = NULL;
	GError * _inner_error_ = NULL;
	_tmp0_ = ((SdxMathTweenbase*) self)->target;
	if (_tmp0_ == NULL) {
		SdxMathTweenbase* _tmp1_ = NULL;
		_tmp1_ = _sdx_math_tweenbase_retain0 ((SdxMathTweenbase*) self);
		result = _tmp1_;
		return result;
	}
	_tmp2_ = sdx_math_tweenbase_registeredAccessors;
	_tmp3_ = ((SdxMathTweenbase*) self)->targetClass;
	_tmp4_ = g_hash_table_lookup (_tmp2_, _tmp3_);
	_tmp5_ = _sdx_math_tween_accessor_retain0 ((SdxMathTweenAccessor*) _tmp4_);
	_sdx_math_tween_accessor_release0 (((SdxMathTweenbase*) self)->accessor);
	((SdxMathTweenbase*) self)->accessor = _tmp5_;
	_tmp6_ = ((SdxMathTweenbase*) self)->accessor;
	if (_tmp6_ != NULL) {
		SdxMathTweenAccessor* _tmp7_ = NULL;
		SdxMathTweenAccessorGetValues _tmp8_ = NULL;
		void* _tmp8__target = NULL;
		void* _tmp9_ = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		_tmp7_ = ((SdxMathTweenbase*) self)->accessor;
		_tmp8_ = _tmp7_->GetValues;
		_tmp8__target = _tmp7_->GetValues_target;
		_tmp9_ = ((SdxMathTweenbase*) self)->target;
		_tmp10_ = ((SdxMathTweenbase*) self)->type;
		_tmp11_ = _tmp8_ (_tmp9_, _tmp10_, &((SdxMathTweenbase*) self)->accessorBuffer, &((SdxMathTweenbase*) self)->accessorBuffer_length1, _tmp8__target);
		((SdxMathTweenbase*) self)->combinedAttrsCnt = _tmp11_;
	} else {
		GError* _tmp12_ = NULL;
		_tmp12_ = g_error_new_literal (SDX_EXCEPTION, SDX_EXCEPTION_RuntimeException, "No TweenAccessor was found for the target");
		_inner_error_ = _tmp12_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp13_ = ((SdxMathTweenbase*) self)->combinedAttrsCnt;
	_tmp14_ = sdx_math_tweenbase_combinedAttrsLimit;
	if (_tmp13_ > _tmp14_) {
		GError* _tmp15_ = NULL;
		_tmp15_ = g_error_new_literal (SDX_EXCEPTION, SDX_EXCEPTION_IllegalArgumentException, "CombinedAttrsLimitReached");
		_inner_error_ = _tmp15_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp16_ = _sdx_math_tweenbase_retain0 ((SdxMathTweenbase*) self);
	result = _tmp16_;
	return result;
}


static SdxMathTweenbase* ___lambda118__sdx_math_tweenbase_tween_build (gpointer self) {
	SdxMathTweenbase* result;
	result = __lambda118_ ((SdxMathTween*) self);
	return result;
}


static void __lambda119_ (SdxMathTween* self) {
	void* _tmp0_ = NULL;
	SdxMathTweenAccessor* _tmp1_ = NULL;
	SdxMathTweenAccessorGetValues _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	void* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	_tmp0_ = ((SdxMathTweenbase*) self)->target;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = ((SdxMathTweenbase*) self)->accessor;
	_tmp2_ = _tmp1_->GetValues;
	_tmp2__target = _tmp1_->GetValues_target;
	_tmp3_ = ((SdxMathTweenbase*) self)->target;
	_tmp4_ = ((SdxMathTweenbase*) self)->type;
	_tmp2_ (_tmp3_, _tmp4_, &((SdxMathTweenbase*) self)->startValues, &((SdxMathTweenbase*) self)->startValues_length1, _tmp2__target);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp5_ = FALSE;
			_tmp5_ = TRUE;
			while (TRUE) {
				gint _tmp7_ = 0;
				gint _tmp8_ = 0;
				gfloat _tmp9_ = 0.0F;
				gboolean _tmp10_ = FALSE;
				gfloat* _tmp14_ = NULL;
				gint _tmp14__length1 = 0;
				gint _tmp15_ = 0;
				gfloat _tmp16_ = 0.0F;
				gboolean _tmp17_ = FALSE;
				if (!_tmp5_) {
					gint _tmp6_ = 0;
					_tmp6_ = i;
					i = _tmp6_ + 1;
				}
				_tmp5_ = FALSE;
				_tmp7_ = i;
				_tmp8_ = ((SdxMathTweenbase*) self)->combinedAttrsCnt;
				if (!(_tmp7_ < _tmp8_)) {
					break;
				}
				_tmp10_ = ((SdxMathTweenbase*) self)->isRelative;
				if (_tmp10_) {
					gfloat* _tmp11_ = NULL;
					gint _tmp11__length1 = 0;
					gint _tmp12_ = 0;
					gfloat _tmp13_ = 0.0F;
					_tmp11_ = ((SdxMathTweenbase*) self)->startValues;
					_tmp11__length1 = ((SdxMathTweenbase*) self)->startValues_length1;
					_tmp12_ = i;
					_tmp13_ = _tmp11_[_tmp12_];
					_tmp9_ = _tmp13_;
				} else {
					_tmp9_ = (gfloat) 0;
				}
				_tmp14_ = ((SdxMathTweenbase*) self)->targetValues;
				_tmp14__length1 = ((SdxMathTweenbase*) self)->targetValues_length1;
				_tmp15_ = i;
				_tmp14_[_tmp15_] += _tmp9_;
				_tmp16_ = _tmp14_[_tmp15_];
				_tmp17_ = ((SdxMathTweenbase*) self)->isFrom;
				if (_tmp17_) {
					gfloat tmp = 0.0F;
					gfloat* _tmp18_ = NULL;
					gint _tmp18__length1 = 0;
					gint _tmp19_ = 0;
					gfloat _tmp20_ = 0.0F;
					gfloat* _tmp21_ = NULL;
					gint _tmp21__length1 = 0;
					gint _tmp22_ = 0;
					gfloat* _tmp23_ = NULL;
					gint _tmp23__length1 = 0;
					gint _tmp24_ = 0;
					gfloat _tmp25_ = 0.0F;
					gfloat _tmp26_ = 0.0F;
					gfloat* _tmp27_ = NULL;
					gint _tmp27__length1 = 0;
					gint _tmp28_ = 0;
					gfloat _tmp29_ = 0.0F;
					gfloat _tmp30_ = 0.0F;
					_tmp18_ = ((SdxMathTweenbase*) self)->startValues;
					_tmp18__length1 = ((SdxMathTweenbase*) self)->startValues_length1;
					_tmp19_ = i;
					_tmp20_ = _tmp18_[_tmp19_];
					tmp = _tmp20_;
					_tmp21_ = ((SdxMathTweenbase*) self)->startValues;
					_tmp21__length1 = ((SdxMathTweenbase*) self)->startValues_length1;
					_tmp22_ = i;
					_tmp23_ = ((SdxMathTweenbase*) self)->targetValues;
					_tmp23__length1 = ((SdxMathTweenbase*) self)->targetValues_length1;
					_tmp24_ = i;
					_tmp25_ = _tmp23_[_tmp24_];
					_tmp21_[_tmp22_] = _tmp25_;
					_tmp26_ = _tmp21_[_tmp22_];
					_tmp27_ = ((SdxMathTweenbase*) self)->targetValues;
					_tmp27__length1 = ((SdxMathTweenbase*) self)->targetValues_length1;
					_tmp28_ = i;
					_tmp29_ = tmp;
					_tmp27_[_tmp28_] = _tmp29_;
					_tmp30_ = _tmp27_[_tmp28_];
				}
			}
		}
	}
}


static void ___lambda119__sdx_math_tweenbase_tween_initialize_override (gpointer self) {
	__lambda119_ ((SdxMathTween*) self);
}


static void __lambda120_ (SdxMathTween* self, gint step, gint lastStep, gboolean isIterationStep, gfloat delta) {
	gboolean _tmp0_ = FALSE;
	void* _tmp1_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp17_ = FALSE;
	gboolean _tmp18_ = FALSE;
	gboolean _tmp31_ = FALSE;
	gfloat _tmp32_ = 0.0F;
	gfloat _tmp33_ = 0.0F;
	gfloat _tmp34_ = 0.0F;
	gboolean _tmp35_ = FALSE;
	gfloat _tmp36_ = 0.0F;
	gboolean _tmp48_ = FALSE;
	gfloat _tmp49_ = 0.0F;
	gfloat _tmp61_ = 0.0F;
	gint _tmp62_ = 0;
	gboolean _tmp63_ = FALSE;
	gfloat time = 0.0F;
	gfloat t = 0.0F;
	SdxMathInterpolation* _tmp67_ = NULL;
	SdxMathInterpolationInterpolationApply _tmp68_ = NULL;
	void* _tmp68__target = NULL;
	gfloat _tmp69_ = 0.0F;
	gfloat _tmp70_ = 0.0F;
	gfloat _tmp71_ = 0.0F;
	SdxMathTweenAccessor* _tmp89_ = NULL;
	SdxMathTweenAccessorSetValues _tmp90_ = NULL;
	void* _tmp90__target = NULL;
	void* _tmp91_ = NULL;
	gint _tmp92_ = 0;
	_tmp1_ = ((SdxMathTweenbase*) self)->target;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		SdxMathInterpolation* _tmp2_ = NULL;
		_tmp2_ = ((SdxMathTweenbase*) self)->equation;
		_tmp0_ = _tmp2_ == NULL;
	}
	if (_tmp0_) {
		return;
	}
	_tmp4_ = isIterationStep;
	if (!_tmp4_) {
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp5_ = step;
		_tmp6_ = lastStep;
		_tmp3_ = _tmp5_ > _tmp6_;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		gint _tmp7_ = 0;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = lastStep;
		_tmp8_ = sdx_math_tweenbase_IsReverse ((SdxMathTweenbase*) self, _tmp7_);
		if (_tmp8_) {
			SdxMathTweenAccessor* _tmp9_ = NULL;
			SdxMathTweenAccessorSetValues _tmp10_ = NULL;
			void* _tmp10__target = NULL;
			void* _tmp11_ = NULL;
			gint _tmp12_ = 0;
			_tmp9_ = ((SdxMathTweenbase*) self)->accessor;
			_tmp10_ = _tmp9_->SetValues;
			_tmp10__target = _tmp9_->SetValues_target;
			_tmp11_ = ((SdxMathTweenbase*) self)->target;
			_tmp12_ = ((SdxMathTweenbase*) self)->type;
			_tmp10_ (_tmp11_, _tmp12_, &((SdxMathTweenbase*) self)->startValues, &((SdxMathTweenbase*) self)->startValues_length1, _tmp10__target);
		} else {
			SdxMathTweenAccessor* _tmp13_ = NULL;
			SdxMathTweenAccessorSetValues _tmp14_ = NULL;
			void* _tmp14__target = NULL;
			void* _tmp15_ = NULL;
			gint _tmp16_ = 0;
			_tmp13_ = ((SdxMathTweenbase*) self)->accessor;
			_tmp14_ = _tmp13_->SetValues;
			_tmp14__target = _tmp13_->SetValues_target;
			_tmp15_ = ((SdxMathTweenbase*) self)->target;
			_tmp16_ = ((SdxMathTweenbase*) self)->type;
			_tmp14_ (_tmp15_, _tmp16_, &((SdxMathTweenbase*) self)->targetValues, &((SdxMathTweenbase*) self)->targetValues_length1, _tmp14__target);
		}
		return;
	}
	_tmp18_ = isIterationStep;
	if (!_tmp18_) {
		gint _tmp19_ = 0;
		gint _tmp20_ = 0;
		_tmp19_ = step;
		_tmp20_ = lastStep;
		_tmp17_ = _tmp19_ < _tmp20_;
	} else {
		_tmp17_ = FALSE;
	}
	if (_tmp17_) {
		gint _tmp21_ = 0;
		gboolean _tmp22_ = FALSE;
		_tmp21_ = lastStep;
		_tmp22_ = sdx_math_tweenbase_IsReverse ((SdxMathTweenbase*) self, _tmp21_);
		if (_tmp22_) {
			SdxMathTweenAccessor* _tmp23_ = NULL;
			SdxMathTweenAccessorSetValues _tmp24_ = NULL;
			void* _tmp24__target = NULL;
			void* _tmp25_ = NULL;
			gint _tmp26_ = 0;
			_tmp23_ = ((SdxMathTweenbase*) self)->accessor;
			_tmp24_ = _tmp23_->SetValues;
			_tmp24__target = _tmp23_->SetValues_target;
			_tmp25_ = ((SdxMathTweenbase*) self)->target;
			_tmp26_ = ((SdxMathTweenbase*) self)->type;
			_tmp24_ (_tmp25_, _tmp26_, &((SdxMathTweenbase*) self)->targetValues, &((SdxMathTweenbase*) self)->targetValues_length1, _tmp24__target);
		} else {
			SdxMathTweenAccessor* _tmp27_ = NULL;
			SdxMathTweenAccessorSetValues _tmp28_ = NULL;
			void* _tmp28__target = NULL;
			void* _tmp29_ = NULL;
			gint _tmp30_ = 0;
			_tmp27_ = ((SdxMathTweenbase*) self)->accessor;
			_tmp28_ = _tmp27_->SetValues;
			_tmp28__target = _tmp27_->SetValues_target;
			_tmp29_ = ((SdxMathTweenbase*) self)->target;
			_tmp30_ = ((SdxMathTweenbase*) self)->type;
			_tmp28_ (_tmp29_, _tmp30_, &((SdxMathTweenbase*) self)->startValues, &((SdxMathTweenbase*) self)->startValues_length1, _tmp28__target);
		}
		return;
	}
	_tmp31_ = isIterationStep;
	_vala_assert (_tmp31_, "isIterationStep");
	_tmp32_ = sdx_math_tweenbase_GetCurrentTime ((SdxMathTweenbase*) self);
	_vala_assert (_tmp32_ >= ((gfloat) 0), "GetCurrentTime() >= 0");
	_tmp33_ = sdx_math_tweenbase_GetCurrentTime ((SdxMathTweenbase*) self);
	_tmp34_ = ((SdxMathTweenbase*) self)->duration;
	_vala_assert (_tmp33_ <= _tmp34_, "GetCurrentTime() <= duration");
	_tmp36_ = ((SdxMathTweenbase*) self)->duration;
	if (_tmp36_ < 0.00000000001f) {
		gfloat _tmp37_ = 0.0F;
		_tmp37_ = delta;
		_tmp35_ = _tmp37_ > (-0.00000000001f);
	} else {
		_tmp35_ = FALSE;
	}
	if (_tmp35_) {
		gint _tmp38_ = 0;
		gboolean _tmp39_ = FALSE;
		_tmp38_ = step;
		_tmp39_ = sdx_math_tweenbase_IsReverse ((SdxMathTweenbase*) self, _tmp38_);
		if (_tmp39_) {
			SdxMathTweenAccessor* _tmp40_ = NULL;
			SdxMathTweenAccessorSetValues _tmp41_ = NULL;
			void* _tmp41__target = NULL;
			void* _tmp42_ = NULL;
			gint _tmp43_ = 0;
			_tmp40_ = ((SdxMathTweenbase*) self)->accessor;
			_tmp41_ = _tmp40_->SetValues;
			_tmp41__target = _tmp40_->SetValues_target;
			_tmp42_ = ((SdxMathTweenbase*) self)->target;
			_tmp43_ = ((SdxMathTweenbase*) self)->type;
			_tmp41_ (_tmp42_, _tmp43_, &((SdxMathTweenbase*) self)->targetValues, &((SdxMathTweenbase*) self)->targetValues_length1, _tmp41__target);
		} else {
			SdxMathTweenAccessor* _tmp44_ = NULL;
			SdxMathTweenAccessorSetValues _tmp45_ = NULL;
			void* _tmp45__target = NULL;
			void* _tmp46_ = NULL;
			gint _tmp47_ = 0;
			_tmp44_ = ((SdxMathTweenbase*) self)->accessor;
			_tmp45_ = _tmp44_->SetValues;
			_tmp45__target = _tmp44_->SetValues_target;
			_tmp46_ = ((SdxMathTweenbase*) self)->target;
			_tmp47_ = ((SdxMathTweenbase*) self)->type;
			_tmp45_ (_tmp46_, _tmp47_, &((SdxMathTweenbase*) self)->startValues, &((SdxMathTweenbase*) self)->startValues_length1, _tmp45__target);
		}
		return;
	}
	_tmp49_ = ((SdxMathTweenbase*) self)->duration;
	if (_tmp49_ < 0.00000000001f) {
		gfloat _tmp50_ = 0.0F;
		_tmp50_ = delta;
		_tmp48_ = _tmp50_ < 0.00000000001f;
	} else {
		_tmp48_ = FALSE;
	}
	if (_tmp48_) {
		gint _tmp51_ = 0;
		gboolean _tmp52_ = FALSE;
		_tmp51_ = step;
		_tmp52_ = sdx_math_tweenbase_IsReverse ((SdxMathTweenbase*) self, _tmp51_);
		if (_tmp52_) {
			SdxMathTweenAccessor* _tmp53_ = NULL;
			SdxMathTweenAccessorSetValues _tmp54_ = NULL;
			void* _tmp54__target = NULL;
			void* _tmp55_ = NULL;
			gint _tmp56_ = 0;
			_tmp53_ = ((SdxMathTweenbase*) self)->accessor;
			_tmp54_ = _tmp53_->SetValues;
			_tmp54__target = _tmp53_->SetValues_target;
			_tmp55_ = ((SdxMathTweenbase*) self)->target;
			_tmp56_ = ((SdxMathTweenbase*) self)->type;
			_tmp54_ (_tmp55_, _tmp56_, &((SdxMathTweenbase*) self)->startValues, &((SdxMathTweenbase*) self)->startValues_length1, _tmp54__target);
		} else {
			SdxMathTweenAccessor* _tmp57_ = NULL;
			SdxMathTweenAccessorSetValues _tmp58_ = NULL;
			void* _tmp58__target = NULL;
			void* _tmp59_ = NULL;
			gint _tmp60_ = 0;
			_tmp57_ = ((SdxMathTweenbase*) self)->accessor;
			_tmp58_ = _tmp57_->SetValues;
			_tmp58__target = _tmp57_->SetValues_target;
			_tmp59_ = ((SdxMathTweenbase*) self)->target;
			_tmp60_ = ((SdxMathTweenbase*) self)->type;
			_tmp58_ (_tmp59_, _tmp60_, &((SdxMathTweenbase*) self)->targetValues, &((SdxMathTweenbase*) self)->targetValues_length1, _tmp58__target);
		}
		return;
	}
	_tmp62_ = step;
	_tmp63_ = sdx_math_tweenbase_IsReverse ((SdxMathTweenbase*) self, _tmp62_);
	if (_tmp63_) {
		gfloat _tmp64_ = 0.0F;
		gfloat _tmp65_ = 0.0F;
		_tmp64_ = ((SdxMathTweenbase*) self)->duration;
		_tmp65_ = sdx_math_tweenbase_GetCurrentTime ((SdxMathTweenbase*) self);
		_tmp61_ = _tmp64_ - _tmp65_;
	} else {
		gfloat _tmp66_ = 0.0F;
		_tmp66_ = sdx_math_tweenbase_GetCurrentTime ((SdxMathTweenbase*) self);
		_tmp61_ = _tmp66_;
	}
	time = _tmp61_;
	_tmp67_ = ((SdxMathTweenbase*) self)->equation;
	_tmp68_ = _tmp67_->Apply;
	_tmp68__target = _tmp67_->Apply_target;
	_tmp69_ = time;
	_tmp70_ = ((SdxMathTweenbase*) self)->duration;
	_tmp71_ = _tmp68_ (_tmp69_ / _tmp70_, _tmp68__target);
	t = _tmp71_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp72_ = FALSE;
			_tmp72_ = TRUE;
			while (TRUE) {
				gint _tmp74_ = 0;
				gint _tmp75_ = 0;
				gfloat* _tmp76_ = NULL;
				gint _tmp76__length1 = 0;
				gint _tmp77_ = 0;
				gfloat* _tmp78_ = NULL;
				gint _tmp78__length1 = 0;
				gint _tmp79_ = 0;
				gfloat _tmp80_ = 0.0F;
				gfloat _tmp81_ = 0.0F;
				gfloat* _tmp82_ = NULL;
				gint _tmp82__length1 = 0;
				gint _tmp83_ = 0;
				gfloat _tmp84_ = 0.0F;
				gfloat* _tmp85_ = NULL;
				gint _tmp85__length1 = 0;
				gint _tmp86_ = 0;
				gfloat _tmp87_ = 0.0F;
				gfloat _tmp88_ = 0.0F;
				if (!_tmp72_) {
					gint _tmp73_ = 0;
					_tmp73_ = i;
					i = _tmp73_ + 1;
				}
				_tmp72_ = FALSE;
				_tmp74_ = i;
				_tmp75_ = ((SdxMathTweenbase*) self)->combinedAttrsCnt;
				if (!(_tmp74_ < _tmp75_)) {
					break;
				}
				_tmp76_ = ((SdxMathTweenbase*) self)->accessorBuffer;
				_tmp76__length1 = ((SdxMathTweenbase*) self)->accessorBuffer_length1;
				_tmp77_ = i;
				_tmp78_ = ((SdxMathTweenbase*) self)->startValues;
				_tmp78__length1 = ((SdxMathTweenbase*) self)->startValues_length1;
				_tmp79_ = i;
				_tmp80_ = _tmp78_[_tmp79_];
				_tmp81_ = t;
				_tmp82_ = ((SdxMathTweenbase*) self)->targetValues;
				_tmp82__length1 = ((SdxMathTweenbase*) self)->targetValues_length1;
				_tmp83_ = i;
				_tmp84_ = _tmp82_[_tmp83_];
				_tmp85_ = ((SdxMathTweenbase*) self)->startValues;
				_tmp85__length1 = ((SdxMathTweenbase*) self)->startValues_length1;
				_tmp86_ = i;
				_tmp87_ = _tmp85_[_tmp86_];
				_tmp76_[_tmp77_] = _tmp80_ + (_tmp81_ * (_tmp84_ - _tmp87_));
				_tmp88_ = _tmp76_[_tmp77_];
			}
		}
	}
	_tmp89_ = ((SdxMathTweenbase*) self)->accessor;
	_tmp90_ = _tmp89_->SetValues;
	_tmp90__target = _tmp89_->SetValues_target;
	_tmp91_ = ((SdxMathTweenbase*) self)->target;
	_tmp92_ = ((SdxMathTweenbase*) self)->type;
	_tmp90_ (_tmp91_, _tmp92_, &((SdxMathTweenbase*) self)->accessorBuffer, &((SdxMathTweenbase*) self)->accessorBuffer_length1, _tmp90__target);
}


static void ___lambda120__sdx_math_tweenbase_tween_update_override (gint step, gint lastStep, gboolean isIterationStep, gfloat delta, gpointer self) {
	__lambda120_ ((SdxMathTween*) self, step, lastStep, isIterationStep, delta);
}


static void __lambda121_ (SdxMathTween* self) {
	void* _tmp0_ = NULL;
	SdxMathTweenAccessor* _tmp1_ = NULL;
	SdxMathTweenAccessorSetValues _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	void* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	_tmp0_ = ((SdxMathTweenbase*) self)->target;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = ((SdxMathTweenbase*) self)->accessor;
	_tmp2_ = _tmp1_->SetValues;
	_tmp2__target = _tmp1_->SetValues_target;
	_tmp3_ = ((SdxMathTweenbase*) self)->target;
	_tmp4_ = ((SdxMathTweenbase*) self)->type;
	_tmp2_ (_tmp3_, _tmp4_, &((SdxMathTweenbase*) self)->startValues, &((SdxMathTweenbase*) self)->startValues_length1, _tmp2__target);
}


static void ___lambda121__sdx_math_tweenbase_tween_force_start_values (gpointer self) {
	__lambda121_ ((SdxMathTween*) self);
}


static void __lambda122_ (SdxMathTween* self) {
	void* _tmp0_ = NULL;
	SdxMathTweenAccessor* _tmp1_ = NULL;
	SdxMathTweenAccessorSetValues _tmp2_ = NULL;
	void* _tmp2__target = NULL;
	void* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	_tmp0_ = ((SdxMathTweenbase*) self)->target;
	if (_tmp0_ == NULL) {
		return;
	}
	_tmp1_ = ((SdxMathTweenbase*) self)->accessor;
	_tmp2_ = _tmp1_->SetValues;
	_tmp2__target = _tmp1_->SetValues_target;
	_tmp3_ = ((SdxMathTweenbase*) self)->target;
	_tmp4_ = ((SdxMathTweenbase*) self)->type;
	_tmp2_ (_tmp3_, _tmp4_, &((SdxMathTweenbase*) self)->targetValues, &((SdxMathTweenbase*) self)->targetValues_length1, _tmp2__target);
}


static void ___lambda122__sdx_math_tweenbase_tween_force_end_values (gpointer self) {
	__lambda122_ ((SdxMathTween*) self);
}


static gboolean __lambda123_ (SdxMathTween* self, void* target, gint tweenType) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_ = 0;
	_tmp1_ = tweenType;
	if (_tmp1_ < 0) {
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		_tmp2_ = ((SdxMathTweenbase*) self)->target;
		_tmp3_ = target;
		_tmp0_ = _tmp2_ == _tmp3_;
	} else {
		gboolean _tmp4_ = FALSE;
		void* _tmp5_ = NULL;
		void* _tmp6_ = NULL;
		_tmp5_ = ((SdxMathTweenbase*) self)->target;
		_tmp6_ = target;
		if (_tmp5_ == _tmp6_) {
			gint _tmp7_ = 0;
			gint _tmp8_ = 0;
			_tmp7_ = ((SdxMathTweenbase*) self)->type;
			_tmp8_ = tweenType;
			_tmp4_ = _tmp7_ == _tmp8_;
		} else {
			_tmp4_ = FALSE;
		}
		_tmp0_ = _tmp4_;
	}
	result = _tmp0_;
	return result;
}


static gboolean ___lambda123__sdx_math_tweenbase_tween_contains_target (void* target, gint tweenType, gpointer self) {
	gboolean result;
	result = __lambda123_ ((SdxMathTween*) self, target, tweenType);
	return result;
}


void sdx_math_tween_Overrides (SdxMathTween* self) {
	Block25Data* _data25_;
	SdxMathTweenbaseTweenReset _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	g_return_if_fail (self != NULL);
	_data25_ = g_slice_new0 (Block25Data);
	_data25_->_ref_count_ = 1;
	_data25_->self = sdx_math_tweenbase_retain (self);
	_tmp0_ = ((SdxMathTweenbase*) self)->Reset;
	_tmp0__target = ((SdxMathTweenbase*) self)->Reset_target;
	_data25_->Reset_ = _tmp0_;
	_data25_->Reset__target = _tmp0__target;
	_data25_->Reset__target_destroy_notify = NULL;
	(((SdxMathTweenbase*) self)->Reset_target_destroy_notify == NULL) ? NULL : (((SdxMathTweenbase*) self)->Reset_target_destroy_notify (((SdxMathTweenbase*) self)->Reset_target), NULL);
	((SdxMathTweenbase*) self)->Reset = NULL;
	((SdxMathTweenbase*) self)->Reset_target = NULL;
	((SdxMathTweenbase*) self)->Reset_target_destroy_notify = NULL;
	((SdxMathTweenbase*) self)->Reset = ___lambda117__sdx_math_tweenbase_tween_reset;
	((SdxMathTweenbase*) self)->Reset_target = block25_data_ref (_data25_);
	((SdxMathTweenbase*) self)->Reset_target_destroy_notify = block25_data_unref;
	(((SdxMathTweenbase*) self)->Build_target_destroy_notify == NULL) ? NULL : (((SdxMathTweenbase*) self)->Build_target_destroy_notify (((SdxMathTweenbase*) self)->Build_target), NULL);
	((SdxMathTweenbase*) self)->Build = NULL;
	((SdxMathTweenbase*) self)->Build_target = NULL;
	((SdxMathTweenbase*) self)->Build_target_destroy_notify = NULL;
	((SdxMathTweenbase*) self)->Build = ___lambda118__sdx_math_tweenbase_tween_build;
	((SdxMathTweenbase*) self)->Build_target = sdx_math_tweenbase_retain (self);
	((SdxMathTweenbase*) self)->Build_target_destroy_notify = sdx_math_tweenbase_release;
	(((SdxMathTweenbase*) self)->InitializeOverride_target_destroy_notify == NULL) ? NULL : (((SdxMathTweenbase*) self)->InitializeOverride_target_destroy_notify (((SdxMathTweenbase*) self)->InitializeOverride_target), NULL);
	((SdxMathTweenbase*) self)->InitializeOverride = NULL;
	((SdxMathTweenbase*) self)->InitializeOverride_target = NULL;
	((SdxMathTweenbase*) self)->InitializeOverride_target_destroy_notify = NULL;
	((SdxMathTweenbase*) self)->InitializeOverride = ___lambda119__sdx_math_tweenbase_tween_initialize_override;
	((SdxMathTweenbase*) self)->InitializeOverride_target = sdx_math_tweenbase_retain (self);
	((SdxMathTweenbase*) self)->InitializeOverride_target_destroy_notify = sdx_math_tweenbase_release;
	(((SdxMathTweenbase*) self)->UpdateOverride_target_destroy_notify == NULL) ? NULL : (((SdxMathTweenbase*) self)->UpdateOverride_target_destroy_notify (((SdxMathTweenbase*) self)->UpdateOverride_target), NULL);
	((SdxMathTweenbase*) self)->UpdateOverride = NULL;
	((SdxMathTweenbase*) self)->UpdateOverride_target = NULL;
	((SdxMathTweenbase*) self)->UpdateOverride_target_destroy_notify = NULL;
	((SdxMathTweenbase*) self)->UpdateOverride = ___lambda120__sdx_math_tweenbase_tween_update_override;
	((SdxMathTweenbase*) self)->UpdateOverride_target = sdx_math_tweenbase_retain (self);
	((SdxMathTweenbase*) self)->UpdateOverride_target_destroy_notify = sdx_math_tweenbase_release;
	(((SdxMathTweenbase*) self)->ForceStartValues_target_destroy_notify == NULL) ? NULL : (((SdxMathTweenbase*) self)->ForceStartValues_target_destroy_notify (((SdxMathTweenbase*) self)->ForceStartValues_target), NULL);
	((SdxMathTweenbase*) self)->ForceStartValues = NULL;
	((SdxMathTweenbase*) self)->ForceStartValues_target = NULL;
	((SdxMathTweenbase*) self)->ForceStartValues_target_destroy_notify = NULL;
	((SdxMathTweenbase*) self)->ForceStartValues = ___lambda121__sdx_math_tweenbase_tween_force_start_values;
	((SdxMathTweenbase*) self)->ForceStartValues_target = sdx_math_tweenbase_retain (self);
	((SdxMathTweenbase*) self)->ForceStartValues_target_destroy_notify = sdx_math_tweenbase_release;
	(((SdxMathTweenbase*) self)->ForceEndValues_target_destroy_notify == NULL) ? NULL : (((SdxMathTweenbase*) self)->ForceEndValues_target_destroy_notify (((SdxMathTweenbase*) self)->ForceEndValues_target), NULL);
	((SdxMathTweenbase*) self)->ForceEndValues = NULL;
	((SdxMathTweenbase*) self)->ForceEndValues_target = NULL;
	((SdxMathTweenbase*) self)->ForceEndValues_target_destroy_notify = NULL;
	((SdxMathTweenbase*) self)->ForceEndValues = ___lambda122__sdx_math_tweenbase_tween_force_end_values;
	((SdxMathTweenbase*) self)->ForceEndValues_target = sdx_math_tweenbase_retain (self);
	((SdxMathTweenbase*) self)->ForceEndValues_target_destroy_notify = sdx_math_tweenbase_release;
	(((SdxMathTweenbase*) self)->ContainsTarget_target_destroy_notify == NULL) ? NULL : (((SdxMathTweenbase*) self)->ContainsTarget_target_destroy_notify (((SdxMathTweenbase*) self)->ContainsTarget_target), NULL);
	((SdxMathTweenbase*) self)->ContainsTarget = NULL;
	((SdxMathTweenbase*) self)->ContainsTarget_target = NULL;
	((SdxMathTweenbase*) self)->ContainsTarget_target_destroy_notify = NULL;
	((SdxMathTweenbase*) self)->ContainsTarget = ___lambda123__sdx_math_tweenbase_tween_contains_target;
	((SdxMathTweenbase*) self)->ContainsTarget_target = sdx_math_tweenbase_retain (self);
	((SdxMathTweenbase*) self)->ContainsTarget_target_destroy_notify = sdx_math_tweenbase_release;
	block25_data_unref (_data25_);
	_data25_ = NULL;
}



