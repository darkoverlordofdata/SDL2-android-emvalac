/* main_save.c generated by valac 0.34.8, the Vala compiler
 * generated from main_save.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_video.h>
#include <SDL2/SDL_render.h>
#include <SDL2/SDL_surface.h>
#include <SDL2/SDL_image.h>

typedef struct _Game Game;
void game_release (Game* self);
void game_free (Game* self);
Game* game_retain (Game* self);
#define _game_release0(var) ((var == NULL) ? NULL : (var = (game_release (var), NULL)))
#define _SDL_DestroyWindow0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyWindow (var), NULL)))
typedef struct _Zed Zed;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))

struct _Zed {
	gint _retainCount;
};


extern gint k;
gint k = 0;
extern gdouble t;
gdouble t = 0.0;
extern gdouble t1;
gdouble t1 = 0.0;
extern gdouble t2;
gdouble t2 = 0.0;
extern gdouble t3;
gdouble t3 = 0.0;
extern gboolean sdx_running;

void game_free (Game* self);
void gameloop (Game* game);
gdouble sdx_getNow (void);
void game_update (Game* self);
void game_draw (Game* self);
gint _vala_main (const gchar* args, int args_length1);
SDL_Window* sdx_initialize (gint width, gint height, const gchar* name);
Game* game_new (gint width, gint height);
void game_initialize (Game* self);
void game_start (Game* self);
void zed_free (Zed* self);
static void zed_instance_init (Zed * self);
Zed* zed_retain (Zed* self);
void zed_release (Zed* self);
void zed_free (Zed* self);
Zed* zed_new (const gchar* file, SDL_Renderer* renderer);


/**
 * gameloop
 * 
 * process each frame
 * 
 * @param game Game object
 * 
 */
void gameloop (Game* game) {
	gdouble _tmp0_ = 0.0;
	Game* _tmp1_ = NULL;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	gdouble _tmp6_ = 0.0;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	Game* _tmp12_ = NULL;
	g_return_if_fail (game != NULL);
	_tmp0_ = sdx_getNow ();
	t1 = _tmp0_;
	_tmp1_ = game;
	game_update (_tmp1_);
	_tmp2_ = sdx_getNow ();
	t2 = _tmp2_;
	_tmp3_ = t2;
	_tmp4_ = t1;
	t3 = _tmp3_ - _tmp4_;
	_tmp5_ = t;
	_tmp6_ = t3;
	t = _tmp5_ + _tmp6_;
	_tmp7_ = k;
	k = _tmp7_ + 1;
	_tmp8_ = k;
	if (_tmp8_ == 1000) {
		gdouble _tmp9_ = 0.0;
		FILE* _tmp10_ = NULL;
		gdouble _tmp11_ = 0.0;
		k = 0;
		_tmp9_ = t;
		t = _tmp9_ / 1000.0;
		_tmp10_ = stdout;
		_tmp11_ = t;
		fprintf (_tmp10_, "%f\n", _tmp11_);
		t = (gdouble) 0;
	}
	_tmp12_ = game;
	game_draw (_tmp12_);
}


/**
 * Start the game
 *
 */
gint _vala_main (const gchar* args, int args_length1) {
	gint result = 0;
	SDL_Window* window = NULL;
	SDL_Window* _tmp0_ = NULL;
	Game* game = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	Game* _tmp3_ = NULL;
	_tmp0_ = sdx_initialize (1184, 768, "Shmupwarz");
	window = _tmp0_;
	_tmp1_ = game_new (1184, 768);
	game = _tmp1_;
	_tmp2_ = game;
	game_initialize (_tmp2_);
	_tmp3_ = game;
	game_start (_tmp3_);
	while (TRUE) {
		gboolean _tmp4_ = FALSE;
		Game* _tmp5_ = NULL;
		_tmp4_ = sdx_running;
		if (!_tmp4_) {
			break;
		}
		_tmp5_ = game;
		gameloop (_tmp5_);
	}
	result = 0;
	_game_release0 (game);
	_SDL_DestroyWindow0 (window);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return _vala_main (argv, argc);
}


Zed* zed_retain (Zed* self) {
	Zed* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->_retainCount), 1);
	result = self;
	return result;
}


void zed_release (Zed* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->_retainCount));
	if (_tmp0_) {
		zed_free (self);
	}
}


Zed* zed_new (const gchar* file, SDL_Renderer* renderer) {
	Zed* self;
	SDL_Surface* never = NULL;
	const gchar* _tmp0_ = NULL;
	SDL_Surface* _tmp1_ = NULL;
	g_return_val_if_fail (file != NULL, NULL);
	g_return_val_if_fail (renderer != NULL, NULL);
	self = g_slice_new0 (Zed);
	zed_instance_init (self);
	_tmp0_ = file;
	_tmp1_ = IMG_Load (_tmp0_);
	never = _tmp1_;
	_SDL_FreeSurface0 (never);
	return self;
}


static void zed_instance_init (Zed * self) {
	self->_retainCount = 1;
}


void zed_free (Zed* self) {
	g_slice_free (Zed, self);
}



