/* Surface.c generated by valac 0.34.8, the Vala compiler
 * generated from Surface.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL2/SDL_surface.h>
#include <stdlib.h>
#include <string.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_rwops.h>

typedef struct _sdxgraphicsSurface sdxgraphicsSurface;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _sdxfilesFileHandle sdxfilesFileHandle;
#define _SDL_FreeRW0(var) ((var == NULL) ? NULL : (var = (SDL_FreeRW (var), NULL)))
void sdx_files_file_handle_release (sdxfilesFileHandle* self);
void sdx_files_file_handle_free (sdxfilesFileHandle* self);
sdxfilesFileHandle* sdx_files_file_handle_retain (sdxfilesFileHandle* self);
#define _sdx_files_file_handle_release0(var) ((var == NULL) ? NULL : (var = (sdx_files_file_handle_release (var), NULL)))

#define TYPE_POOL (pool_get_type ())
void sdx_graphics_surface_release (sdxgraphicsSurface* self);
void sdx_graphics_surface_free (sdxgraphicsSurface* self);
sdxgraphicsSurface* sdx_graphics_surface_retain (sdxgraphicsSurface* self);
#define _sdx_graphics_surface_release0(var) ((var == NULL) ? NULL : (var = (sdx_graphics_surface_release (var), NULL)))

struct _sdxgraphicsSurface {
	gint _retainCount;
	SDL_Surface* surface;
	gint width;
	gint height;
	gint id;
	gchar* path;
};

typedef enum  {
	POOL_BACKGROUND,
	POOL_ENEMY1,
	POOL_ENEMY2,
	POOL_ENEMY3,
	POOL_PLAYER,
	POOL_BULLET,
	POOL_EXPLOSION,
	POOL_BANG,
	POOL_PARTICLE,
	POOL_HUD,
	POOL_Count
} Pool;

typedef enum  {
	SDX_SDL_EXCEPTION_Initialization,
	SDX_SDL_EXCEPTION_ImageInitialization,
	SDX_SDL_EXCEPTION_TtfInitialization,
	SDX_SDL_EXCEPTION_TextureFilteringNotEnabled,
	SDX_SDL_EXCEPTION_OpenWindow,
	SDX_SDL_EXCEPTION_CreateRenderer,
	SDX_SDL_EXCEPTION_InvalidForPlatform,
	SDX_SDL_EXCEPTION_UnableToLoadResource,
	SDX_SDL_EXCEPTION_UnableToLoadSurface,
	SDX_SDL_EXCEPTION_UnableToLoadTexture,
	SDX_SDL_EXCEPTION_NullPointer,
	SDX_SDL_EXCEPTION_NoSuchElement,
	SDX_SDL_EXCEPTION_IllegalStateException,
	SDX_SDL_EXCEPTION_RuntimeException,
	SDX_SDL_EXCEPTION_NotReached
} sdxSdlException;
#define SDX_SDL_EXCEPTION sdx_sdl_exception_quark ()

extern sdxgraphicsSurface** sdx_graphics_surface_cache;
extern gint sdx_graphics_surface_cache_length1;
sdxgraphicsSurface** sdx_graphics_surface_cache = NULL;
gint sdx_graphics_surface_cache_length1 = 0;
extern gint sdx_graphics_surface_uniqueId;
gint sdx_graphics_surface_uniqueId = 0;

void sdx_graphics_surface_free (sdxgraphicsSurface* self);
static void sdx_graphics_surface_instance_init (sdxgraphicsSurface * self);
sdxgraphicsSurface* sdx_graphics_surface_retain (sdxgraphicsSurface* self);
void sdx_graphics_surface_release (sdxgraphicsSurface* self);
void sdx_graphics_surface_free (sdxgraphicsSurface* self);
sdxgraphicsSurface* sdx_graphics_surface_new (const gchar* path);
void sdx_files_file_handle_free (sdxfilesFileHandle* self);
sdxfilesFileHandle* sdx_files_default (const gchar* path);
SDL_RWops* sdx_files_file_handle_getRWops (sdxfilesFileHandle* self);
gint sdx_graphics_surface_indexOfPath (const gchar* path);
GType pool_get_type (void) G_GNUC_CONST;
GQuark sdx_sdl_exception_quark (void);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


sdxgraphicsSurface* sdx_graphics_surface_retain (sdxgraphicsSurface* self) {
	sdxgraphicsSurface* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->_retainCount), 1);
	result = self;
	return result;
}


void sdx_graphics_surface_release (sdxgraphicsSurface* self) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->_retainCount));
	if (_tmp0_) {
		sdx_graphics_surface_free (self);
	}
}


sdxgraphicsSurface* sdx_graphics_surface_new (const gchar* path) {
	sdxgraphicsSurface* self;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	sdxfilesFileHandle* file = NULL;
	const gchar* _tmp2_ = NULL;
	sdxfilesFileHandle* _tmp3_ = NULL;
	SDL_RWops* _tmp4_ = NULL;
	SDL_RWops* _tmp5_ = NULL;
	SDL_Surface* _tmp6_ = NULL;
	SDL_Surface* _tmp7_ = NULL;
	SDL_Surface* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	SDL_Surface* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	g_return_val_if_fail (path != NULL, NULL);
	self = g_slice_new0 (sdxgraphicsSurface);
	sdx_graphics_surface_instance_init (self);
	_tmp0_ = path;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->path);
	self->path = _tmp1_;
	_tmp2_ = path;
	_tmp3_ = sdx_files_default (_tmp2_);
	file = _tmp3_;
	_tmp4_ = sdx_files_file_handle_getRWops (file);
	_tmp5_ = _tmp4_;
	_tmp6_ = IMG_LoadPNG_RW (_tmp5_);
	_SDL_FreeSurface0 (self->surface);
	self->surface = _tmp6_;
	_SDL_FreeRW0 (_tmp5_);
	_tmp7_ = self->surface;
	SDL_SetSurfaceAlphaMod (_tmp7_, (guint8) 0xff);
	_tmp8_ = self->surface;
	_tmp9_ = _tmp8_->w;
	self->width = _tmp9_;
	_tmp10_ = self->surface;
	_tmp11_ = _tmp10_->h;
	self->height = _tmp11_;
	_sdx_files_file_handle_release0 (file);
	return self;
}


gint sdx_graphics_surface_indexOfPath (const gchar* path) {
	gint result = 0;
	sdxgraphicsSurface** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	GError* _tmp19_ = NULL;
	gint _tmp20_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (path != NULL, 0);
	_tmp0_ = sdx_graphics_surface_cache;
	_tmp0__length1 = sdx_graphics_surface_cache_length1;
	if (_tmp0__length1 == 0) {
		sdxgraphicsSurface** _tmp1_ = NULL;
		_tmp1_ = g_new0 (sdxgraphicsSurface*, POOL_Count + 1);
		sdx_graphics_surface_cache = (_vala_array_free (sdx_graphics_surface_cache, sdx_graphics_surface_cache_length1, (GDestroyNotify) sdx_graphics_surface_release), NULL);
		sdx_graphics_surface_cache = _tmp1_;
		sdx_graphics_surface_cache_length1 = POOL_Count;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_ = 0;
				sdxgraphicsSurface** _tmp5_ = NULL;
				gint _tmp5__length1 = 0;
				sdxgraphicsSurface** _tmp6_ = NULL;
				gint _tmp6__length1 = 0;
				gint _tmp7_ = 0;
				sdxgraphicsSurface* _tmp8_ = NULL;
				sdxgraphicsSurface** _tmp14_ = NULL;
				gint _tmp14__length1 = 0;
				gint _tmp15_ = 0;
				sdxgraphicsSurface* _tmp16_ = NULL;
				const gchar* _tmp17_ = NULL;
				const gchar* _tmp18_ = NULL;
				if (!_tmp2_) {
					gint _tmp3_ = 0;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = sdx_graphics_surface_cache;
				_tmp5__length1 = sdx_graphics_surface_cache_length1;
				if (!(_tmp4_ < _tmp5__length1)) {
					break;
				}
				_tmp6_ = sdx_graphics_surface_cache;
				_tmp6__length1 = sdx_graphics_surface_cache_length1;
				_tmp7_ = i;
				_tmp8_ = _tmp6_[_tmp7_];
				if (_tmp8_ == NULL) {
					sdxgraphicsSurface** _tmp9_ = NULL;
					gint _tmp9__length1 = 0;
					gint _tmp10_ = 0;
					const gchar* _tmp11_ = NULL;
					sdxgraphicsSurface* _tmp12_ = NULL;
					sdxgraphicsSurface* _tmp13_ = NULL;
					_tmp9_ = sdx_graphics_surface_cache;
					_tmp9__length1 = sdx_graphics_surface_cache_length1;
					_tmp10_ = i;
					_tmp11_ = path;
					_tmp12_ = sdx_graphics_surface_new (_tmp11_);
					_sdx_graphics_surface_release0 (_tmp9_[_tmp10_]);
					_tmp9_[_tmp10_] = _tmp12_;
					_tmp13_ = _tmp9_[_tmp10_];
					result = i;
					return result;
				}
				_tmp14_ = sdx_graphics_surface_cache;
				_tmp14__length1 = sdx_graphics_surface_cache_length1;
				_tmp15_ = i;
				_tmp16_ = _tmp14_[_tmp15_];
				_tmp17_ = _tmp16_->path;
				_tmp18_ = path;
				if (g_strcmp0 (_tmp17_, _tmp18_) == 0) {
					result = i;
					return result;
				}
			}
		}
	}
	_tmp19_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_UnableToLoadSurface, "Cache is full");
	_inner_error_ = _tmp19_;
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp20_;
}


static void sdx_graphics_surface_instance_init (sdxgraphicsSurface * self) {
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	self->_retainCount = 1;
	_tmp0_ = sdx_graphics_surface_uniqueId;
	sdx_graphics_surface_uniqueId = _tmp0_ + 1;
	_tmp1_ = sdx_graphics_surface_uniqueId;
	self->id = _tmp1_;
}


void sdx_graphics_surface_free (sdxgraphicsSurface* self) {
	_SDL_FreeSurface0 (self->surface);
	_g_free0 (self->path);
	g_slice_free (sdxgraphicsSurface, self);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



